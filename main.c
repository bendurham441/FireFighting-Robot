#pragma config(Sensor, 	in1,    front_line,     sensorLineFollower)
#pragma config(Sensor, 	in2,    back_line,      sensorLineFollower)
#pragma config(Sensor, 	in3,    light,          sensorReflection)
#pragma config(Sensor, 	dgtl1,  right_sonar,    sensorSONAR_cm)
#pragma config(Sensor, 	dgtl3,  left_sonar,     sensorSONAR_cm)
#pragma config(Sensor, 	dgtl5,  encoder,        sensorQuadEncoder)
#pragma config(Motor,  	port7,  right_motor,    tmotorServoContinuousRotation, 	openLoop)
#pragma config(Motor,  	port9,	left_motor,	tmotorServoContinuousRotation, 	openLoop)
#pragma config(Motor,  	port8,  servo,          tmotorServoStandard,		openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int speed = 63; // The default speed to be used throughout the program

void forward(int speed_param, int time){
	// A simple function to simplify the act of moving forward
	motor[right_motor] = speed_param; 			// Set the motor powers
	motor[left_motor] = speed_param;
	
	if(time != 0) {						// Only use a wait time if the time is specified
		wait1Msec(time);
	}
	
}

void back(int speed_param, int time){
	// A function to make going backward more simple
	motor[right_motor] = speed_param * -1;			// Set the negative of the inputted speed
	motor[left_motor] = speed_param * -1;
	
	if(time != 0) {						// Only use a wait time if the time is specified
		wait1Msec(time);
	}
}

void stop(){
	// A function to stop both motors
	motor[right_motor] = 0;					// Set the motor powers
	motor[left_motor] = 0;
}

void turn_right() {
	// A function to turn the robot to the right
	motor[right_motor] = -63;				// Set the motor powers
	motor[left_motor] = 63;
	wait1Msec(1000);
}

void turn_left() {
	// A function to turn the robot to the left using a point turn
	motor[right_motor] = 63;				// Set the motor powers
	motor[left_motor] = -63;
	wait1Msec(750);
}

void extinguish() {
	/** A function that moves the robot forward with the intent of placing the balloon over top
	 *  of the candle
	 */
	forward(63, 200);
	stop();
	wait1Msec(3000); 					// Wait 3 seconds to hopefully extinguish the fire
	back(63, 200);	 					// Move back to the original position
}

void rotate_arm() {
	// A function to rotate the arm to put the second balloon into place, if necessary
	while(SensorValue[encoder] != 45) { 			// Wait for the servo to turn 45 degrees
		motor[servo] = 63;				// Have the servo spinning while checking the encoder
	}
	
	motor[servo] = 0;					// Stop the servo
}

void rotate() {
	// A function to rotate the robot a small amount in order to scan the room
	motor[right_motor] = 63;				//set the motor powers to the default speed;
	motor[left_motor] = -63;
	wait1Msec(100);
}


void room_scan() {
	// A function to rotate around the room in small increments and check to see if there is a fire
	forward(63, 2000);
	int counter = 0;
	
	while(SensorValue[light] >= 20 && counter < 45) {	// If there is a fire and the robot has not completely turned
		rotate();					// Rotate the robot in small increments and add to the counter
		counter += 1;
	}
	
	extinguish();						// Once the light is enough to meet the criteria, extinguish it
	wait1Msec(1000);					// Wait for a second to see if the fire is still burning
	
	if(SensorValue[light] <= 20) {				// If the fire is still burning
		rotate_arm();					// Rotate the arm, to put the next balloon into place
		extinguish();					// Second attempt to extinguish the fire
	}
}

task main()
{
	wait1Msec(1000);					// Initial wait time
	bMotorReflected[right_motor] = true;			// Make it so the mirroring of the motors does not have to be accounted for
	forward(speed, 0);					// Start the motors
	
	while(SensorValue[right_sonar] <= 15) {			// While the robot is less than 15 cms from a wall
		forward(speed, 0);				// Keep moving forward
	}
	
	forward(speed, 500);					// Move forward before making the turn
	turn_right();						// Make the turn
	forward(speed, 750);					// Move forward again to make sure the robot has passed the wall
	
	while(SensorValue[right_sonar] <= 15) {			// Sense the opening to the first room
		forward(63, 0);
	}
	
	forward(63, 900);					// Move before the turn
	turn_right();						// Turn into the room
	room_scan();						// Scan the room, ending facing the entry
	forward(63, 1000);					// Move out of the room
	turn_left();						// Turn left to go to the next room
	forward(63, 1000);
	
	while(SensorValue[right_sonar] <= 15) {			// Sense the hallway	
		forward(63, 0);
	}
	
	forward(63, 1000);
	turn_right();
	forward(63, 1000);
	
	while(SensorValue[right_sonar] <=15) {
		forward(63, 0);
	}
	
	forward(63, 1000);
	turn_right();
	forward(63, 1000);
	room_scan();
	forward(63, 1000);
	turn_left();
	forward(63, 500);
	
	while(SensorValue[right_sonar] <= 15) {
		forward(63, 0);	
	}
	
	forward(63, 750);
	turn_right();
	forward(63, 750);
	room_scan();
	forward(63, 1000);
	turn_right();
	forward(63, 750);
	
	while(SensorValue[right_sonar] <= 15) {
		forward(63, 0);
	}
	
	forward(63, 750);
	turn_right();
	forward(63, 750);
	
	while(SensorValue[left_sonar] <= 15) {
		forward(63, 0);
	}
	
	forward(63, 750);
	turn_left();
	forward(63, 750);
	room_scan();
	forward(63, 1000);
	turn_right();
	forward(63, 750);
	
	while(SensorValue[right_sonar] <= 15){
		forward(63, 0);
	}
	
	forward(speed, 750);
	turn_right();
	forward(speed, 750);
	
	while(SensorValue[right_sonar] <= 15) {
		forward(63, 0);
	}
	
	forward(63, 1000);
}
