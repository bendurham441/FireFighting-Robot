#pragma config(Sensor, in1,    front_line,     sensorLineFollower)
#pragma config(Sensor, in2,    back_line,      sensorLineFollower)
#pragma config(Sensor, in3,    light,          sensorReflection)
#pragma config(Sensor, dgtl1,  right_sonar,    sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  left_sonar,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  encoder_in,     sensorQuadEncoder)
#pragma config(Motor,  port7,           right_motor,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           left_motor,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const speed = 63; // The default speed to be used throughout the program

void forward(int speed, int time){
	// A simple function to simplify the act of moving forward
	motor[right_motor] = speed; 				// Set the motor powers
	motor[left_motor] = speed;
	if(time != 0) {						// Only use a wait time if the time is specified
		wait1Msec(time);
	}
	
}

void back(int speed, int time){
	// A function to make going backward more simple
	motor[right_motor] = speed * -1;			// Set the negative of the inputted speed
	Motor[left_motor] = speed * -1;
	if(time != 0) {						// Only use a wait time if the time is specified
		wait1Msec(time);
	}
}

void stop(){
	// A function to stop both motors
	motor[right_motor] = 0;					// Set the motor powers
	motor[left_motor] = 0;
}

void turn_right() {
	// A function to turn the robot to the right
	motor[right_motor] = -63;				// Set the motor powers
	motor[left_motor] = 63;
	wait1Msec(750);
}

void turn_left() {
	// A function to turn the robot to the left using a point turn
	motor[right_motor] = 63;				// Set the motor powers
	motor[left_motor] = -63;
	wait1Msec(750);
}

void extinguish() {
	/** A function that moves the robot forward with the intent of placing the balloon over top
	 *  of the candle
	 */
	forward(63, 200);
	stop();
	wait1Msec(3000); 					// Wait 3 seconds to hopefully extinguish the fire
	back(63, 200);	 					// Move back to the original position
}

void rotate_arm() {
	// A function to rotate the arm to put the second balloon into place, if necessary
	while(SensorValue[encoder] != 45) { 			// Wait for the servo to turn 45 degrees
		motor[servo] = 63;				// Have the servo spinning while checking the encoder
	}
	motor[servo] = 0;					// Stop the servo
}

void rotate() {
	// A function to rotate the robot a small amount in order to scan the room
	motor[right_motor] = 63;				//set the motor powers to the default speed;
	motor[left_motor] = -63;
	wait1Msec(100);
}


void room_scan() {
	// A function to rotate around the room in small increments and check to see if there is a fire
	forward(63, 1000);
	int counter = 0;
	while(SensorValue[light] >= 20 && counter < 29) {	// If there is a fire and the robot has not completely turned
		rotate();					// Rotate the robot in small increments and add to the counter
		counter += 1;
	}
	extinguish();						// Once the light is enough to meet the criteria, extinguish it
	wait1Msec(1000);					// Wait for a second to see if the fire is still burning
	if(SensorValue[light] <= 20) {				// If the fire is still burning
		rotate_arm();					// Rotate the arm, to put the next balloon into place
		extinguish();					// Second attempt to extinguish the fire
	}
}

task main()
{
	wait1Msec(1000);					// Initial wait time
	bMotorReflected[right_motor] = true;			// Make it so the mirroring of the motors does not have to be accounted for
	forward(63, 0);						// Start the motors
	while(SensorValue[right_sonar] <= 15) {			// While the robot is less than 15 cms from a wall
		forward(63, 0);					// Keep moving forward
	}
	turn_right();						// Turn right when it has reached a room
	while(SensorValue[right_sonar] <= 15) {
		forward(63, 0);
	}
	turn_right();
	room_scan;
	forward(63);
	wait1Msec(1000);
	turn_left();
	while(SensorValue[left_sonar] <= 15) {
		forward(63);
	}
	turn_right();
	while(SensorValue[right_sonar] <=15) {
		forward();
	}
	turn_right();
	room_scan();
	forward(63);
	wait1Msec(1000);
	turn_left();
	while(SensorValue[right_sonar] <= 15) {
		forward(63);	
	}
	turn_right();
	room_scan();
	forward(63);
	wait1Msec(1000);
	turn_right();
	while(SensorValue[right_sonar] <= 15) {
		forward(63);
	}
	turn_right();
	while(SensorValue[left_sonar] <= 15) {
		forward(63);
	}
	turn_left();
	room_scan();
	forward(63);
	wait1Msec(1000);
	turn_right();
	while(SensorValue[right_sonar] <= 15){
		forward(63);
	}
	turn_right();
	while(SensorValue[right_sonar] <= 15) {
		forward(63);
	}
	stop();
}
